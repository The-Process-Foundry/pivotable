//! A configurable table with autogenerated data
//!
//! Configuration Options:
//! - Overall:
//!   - Is form (aka selectable)
//! - Data:
//!   - Static Data display
//!   - Nubmer of Nodes
//!   - Rename columns
//!   - Change data size/type
//! - Header:
//!   - Title
//!   - Searchable
//!   - Filterable
//!   - Sortable
//! - Body:
//!   - Column Headers:
//!     - Sortable ()
//!     - Alias Name to property
//!     - Group Highlighting? (All items from the same node should be underlined)
//!   - Cell
//!     - Auto-truncate (... with full display when hovered)
//!   - Scrollbar:
//!     - Highlight search matches (Separate project?)
//! - Footer:
//!   - Records displayed
//!   - Page selector ("text cell" of Page Count)

use pivotable::prelude::*;
use tracing::{debug, info};

use yew::prelude::*;

#[function_component]
pub fn App() -> Html {
  html! {
    <Demo />
  }
}

#[derive(Clone, Debug)]
pub enum DemoMsg {
  FetchedConfig(std::result::Result<String, String>),
}

#[derive(Properties, Clone, Debug, PartialEq)]
pub struct DemoProps {
  /// Unique Identifier for Demo
  #[prop_or_default]
  pub id: String,

  /// CSS Classes used for rendering
  #[prop_or_default]
  pub class: Classes,

  /// Child components
  #[prop_or_default]
  pub children: Children,
}

/// Demo
#[derive(Debug)]
pub struct Demo {
  /// Message to be displayed
  error: Option<String>,
  config: Option<PivotableConfig>,
  // data
}

impl Component for Demo {
  type Message = DemoMsg;
  type Properties = DemoProps;

  fn create(ctx: &Context<Demo>) -> Self {
    let callback = ctx.link().callback(DemoMsg::FetchedConfig);
    crate::fetch::get_file("./activity.yml", callback);

    Demo {
      error: None,
      config: None,
    }
  }

  /// The reducer for the demo
  fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {
    match msg {
      DemoMsg::FetchedConfig(result) => {
        match result {
          Err(err) => {
            self.error = Some(format!(
              "Could not fetch the table configuration:\n{:?}",
              err
            ))
          }
          Ok(config) => match serde_yaml::from_str(&config) {
            Ok(config) => self.config = Some(config),
            Err(err) => self.error = Some(format!("Could not parse the configuration:\n{:?}", err)),
          },
        }
        true
      }
    }
  }

  fn view(&self, _ctx: &Context<Demo>) -> Html {
    let mut body = html! {{"Loading ..."}};

    if let Some(err) = &self.error {
      body = html! {{err}};
    } else {
      if let Some(config) = &self.config {
        info!("Successfully retrieved the Pivotable configuration");
        body = html! { <Pivotable config={config.clone()} /> };
      }
    }

    html! {
      <div id="SiteRoot" class={classes!("w-full", "h-screen", "bg-neutral-100", "p-2")}>
        {body}
      </div>
    }
  }

  fn rendered(&mut self, ctx: &Context<Self>, first_render: bool) {
    if first_render {
      debug!("Rendered the demo for the first time");
    }
  }
}

/*
    -webkit-font-smoothing: antialiased;
    background-color: initial;
    background-image: linear-gradient(-180deg, #FF7E31, #E62C03);
    border-radius: 6px;
    color: #FFFFFF;
    cursor: pointer;
    display: inline-block;
    font-family: Inter,-apple-system,system-ui,Roboto,"Helvetica Neue",Arial,sans-serif;
    height: 40px;
    line-height: 40px;
    outline: 0;
    overflow: hidden;
    padding: 0 20px;
    pointer-events: auto;
    position: relative;
    text-align: center;
    touch-action: manipulation;
    -webkit-user-select: none;
    vertical-align: top;
    white-space: nowrap;
    width: 100%;
    z-index: 9;
    border: 0;
    transition: box-shadow .2s;
    box-shadow: rgba(253, 76, 0, 0.5) 0 3px 8px;

*/
