//! Run-time errors specific to the construction and operation of a selector table

use crate::local::*;

// use serde::{Deserialize, Serialize};
use allwhat::ErrorGroup;
use thiserror::Error;

pub type Result<T> = core::result::Result<T, SelectorError>;

/// A structure for capturing errors generated by Grapht
#[derive(Debug, Clone)]
pub struct SelectorError {
  /// The general error genus
  kind: Kind,

  /// An error message geared toward an end user
  comment: Option<String>,

  /// A developer based context object
  /// FIXME: This should be a downcastable object, not a string, usable for both rollbacks and
  ///   debugging
  context: Option<String>,
}

impl std::error::Error for SelectorError {}

impl SelectorError {
  /// Get the kind of error (for matching)
  pub fn kind(&self) -> &Kind {
    &self.kind
  }

  pub fn comment(mut self, comment: String) -> SelectorError {
    self.comment = Some(comment);
    self
  }

  pub fn context(mut self, context: String) -> SelectorError {
    self.context = Some(context);
    self
  }
}

/// An error generated by the Selector
#[derive(Debug, Error, Clone)]
pub enum Kind {
  //-- Generic Errors
  #[error("Multiple errors have been found")]
  // #[serde(
  //   serialize_with = "Kind::serialize_error_list",
  //   deserialize_with = "Kind::deserialize_error_list"
  // )]
  ErrorList(ErrorGroup),

  #[error("A catchall for graceful error handling")]
  GeneralError,

  #[error("Function received a variant value which doesn't work with the current function")]
  InvalidVariant,
}

impl Kind {
  // pub(crate) fn serialize_error_list<S>(_value: &ErrorGroup, _ser: S) -> Result<S::Ok, S::Error>
  // where
  //   S: Serializer,
  // {
  //   todo!("Serialize ErrorList")
  // }

  // pub(crate) fn deserialize_error_list<'de, D>(_de: D) -> Result<ErrorGroup, D::Error>
  // where
  //   D: Deserializer<'de>,
  // {
  //   todo!("Deserialize ErrorList")
  // }
}

impl fmt::Display for SelectorError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let comment = match &self.comment {
      Some(x) => format!("\nt{}", x),
      None => String::new(),
    };

    let context = match &self.context {
      Some(x) => format!("\nt{}", x),
      None => String::new(),
    };

    write!(f, "{}{}{}", self.kind, comment, context)
  }
}

impl SelectorError {
  pub fn new(kind: Kind) -> SelectorError {
    SelectorError {
      kind,
      comment: None,
      context: None,
    }
  }
}

unsafe impl Sync for SelectorError {}

unsafe impl Send for SelectorError {}

pub trait Comment<T, E> {
  fn comment<C>(self, comment: C) -> result::Result<T, SelectorError>
  where
    C: Into<String>;
  fn context<C>(self, ctx: C) -> result::Result<T, SelectorError>
  where
    C: fmt::Display + fmt::Debug + Sync + Send + 'static;
}

impl<T, E> Comment<T, E> for result::Result<T, E>
where
  E: Into<SelectorError>,
{
  fn comment<C>(self, comment: C) -> result::Result<T, SelectorError>
  where
    C: Into<String>,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: SelectorError = err.into();
        err.comment = Some(comment.into());
        Err(err)
      }
    }
  }

  fn context<C>(self, ctx: C) -> result::Result<T, SelectorError>
  where
    C: fmt::Display + fmt::Debug + Sync + Send + 'static,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: SelectorError = err.into();
        err.context = Some(format!("{:#?}", ctx));
        Err(err)
      }
    }
  }
}

impl From<ErrorGroup> for SelectorError {
  fn from(err: ErrorGroup) -> SelectorError {
    SelectorError {
      kind: Kind::ErrorList(err),
      comment: None,
      context: None,
    }
  }
}

/// Simple macro to create an FHL error
#[macro_export]
macro_rules! err {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($kind:ident $(, $($comment:expr),+)?) => {
    SelectorError::new(Kind::$kind)
      $(.comment(err!(@comment $($comment),+)))?
  };
}

#[macro_export]
macro_rules! err_into {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($res:expr $(, $($comment:expr),+)?) => {
    match $res {
      Ok(x) => Ok(x),
      Err(err) =>
        Err(err.into())
          $(.comment::<String>(err_into!(@comment $($comment),+).into()))?,
    }
  };
}

/// Adds a comment/type to the try (?) functionality
#[macro_export]
macro_rules! unwrap {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($res:expr $(, $($comment:expr),+)?) => {
    $res.map_err(|err| FHLError::from(err)$(.comment(unwrap!(@comment $($comment),+)))?,)?
    // match $res {
    //   Ok(x) => x,
    //   Err(err) =>
    //     Err()
    //       $(.comment::<String>(unwrap!(@comment $($comment),+)))??,
    // }
  };
}
